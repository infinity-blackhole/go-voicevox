/*
VOICEVOX Engine

VOICEVOXの音声合成エンジンです。

API version: latest
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package voicevox

import (
	"bytes"
	"context"
	"io"
	"net/http"
	"net/url"
	"os"
)

type OtherApi interface {

	/*
		AddPresetAddPresetPost Add Preset

		新しいプリセットを追加します

	Parameters
	-------
	preset: Preset
	    新しいプリセット。
	    プリセットIDが既存のものと重複している場合は、新規のプリセットIDが採番されます。

	Returns
	-------
	id: int
	    追加したプリセットのプリセットID

		@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
		@return OtherApiAddPresetAddPresetPostRequest
	*/
	AddPresetAddPresetPost(ctx context.Context) OtherApiAddPresetAddPresetPostRequest

	// AddPresetAddPresetPostExecute executes the request
	//  @return int32
	AddPresetAddPresetPostExecute(r OtherApiAddPresetAddPresetPostRequest) (int32, *http.Response, error)

	/*
		ConnectWavesConnectWavesPost base64エンコードされた複数のwavデータを一つに結合する

		base64エンコードされたwavデータを一纏めにし、wavファイルで返します。

		@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
		@return OtherApiConnectWavesConnectWavesPostRequest
	*/
	ConnectWavesConnectWavesPost(ctx context.Context) OtherApiConnectWavesConnectWavesPostRequest

	// ConnectWavesConnectWavesPostExecute executes the request
	//  @return *os.File
	ConnectWavesConnectWavesPostExecute(r OtherApiConnectWavesConnectWavesPostRequest) (*os.File, *http.Response, error)

	/*
		CoreVersionsCoreVersionsGet Core Versions

		@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
		@return OtherApiCoreVersionsCoreVersionsGetRequest
	*/
	CoreVersionsCoreVersionsGet(ctx context.Context) OtherApiCoreVersionsCoreVersionsGetRequest

	// CoreVersionsCoreVersionsGetExecute executes the request
	//  @return []string
	CoreVersionsCoreVersionsGetExecute(r OtherApiCoreVersionsCoreVersionsGetRequest) ([]string, *http.Response, error)

	/*
		DeletePresetDeletePresetPost Delete Preset

		既存のプリセットを削除します

	Parameters
	-------
	id: int
	    削除するプリセットのプリセットID

		@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
		@return OtherApiDeletePresetDeletePresetPostRequest
	*/
	DeletePresetDeletePresetPost(ctx context.Context) OtherApiDeletePresetDeletePresetPostRequest

	// DeletePresetDeletePresetPostExecute executes the request
	DeletePresetDeletePresetPostExecute(r OtherApiDeletePresetDeletePresetPostRequest) (*http.Response, error)

	/*
		EngineManifestEngineManifestGet Engine Manifest

		@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
		@return OtherApiEngineManifestEngineManifestGetRequest
	*/
	EngineManifestEngineManifestGet(ctx context.Context) OtherApiEngineManifestEngineManifestGetRequest

	// EngineManifestEngineManifestGetExecute executes the request
	//  @return EngineManifest
	EngineManifestEngineManifestGetExecute(r OtherApiEngineManifestEngineManifestGetRequest) (*EngineManifest, *http.Response, error)

	/*
		GetPresetsPresetsGet Get Presets

		エンジンが保持しているプリセットの設定を返します

	Returns
	-------
	presets: List[Preset]
	    プリセットのリスト

		@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
		@return OtherApiGetPresetsPresetsGetRequest
	*/
	GetPresetsPresetsGet(ctx context.Context) OtherApiGetPresetsPresetsGetRequest

	// GetPresetsPresetsGetExecute executes the request
	//  @return []Preset
	GetPresetsPresetsGetExecute(r OtherApiGetPresetsPresetsGetRequest) ([]Preset, *http.Response, error)

	/*
		InitializeSpeakerInitializeSpeakerPost Initialize Speaker

		指定されたspeaker_idの話者を初期化します。
	実行しなくても他のAPIは使用できますが、初回実行時に時間がかかることがあります。

		@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
		@return OtherApiInitializeSpeakerInitializeSpeakerPostRequest
	*/
	InitializeSpeakerInitializeSpeakerPost(ctx context.Context) OtherApiInitializeSpeakerInitializeSpeakerPostRequest

	// InitializeSpeakerInitializeSpeakerPostExecute executes the request
	InitializeSpeakerInitializeSpeakerPostExecute(r OtherApiInitializeSpeakerInitializeSpeakerPostRequest) (*http.Response, error)

	/*
		IsInitializedSpeakerIsInitializedSpeakerGet Is Initialized Speaker

		指定されたspeaker_idの話者が初期化されているかどうかを返します。

		@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
		@return OtherApiIsInitializedSpeakerIsInitializedSpeakerGetRequest
	*/
	IsInitializedSpeakerIsInitializedSpeakerGet(ctx context.Context) OtherApiIsInitializedSpeakerIsInitializedSpeakerGetRequest

	// IsInitializedSpeakerIsInitializedSpeakerGetExecute executes the request
	//  @return bool
	IsInitializedSpeakerIsInitializedSpeakerGetExecute(r OtherApiIsInitializedSpeakerIsInitializedSpeakerGetRequest) (bool, *http.Response, error)

	/*
		SpeakerInfoSpeakerInfoGet Speaker Info

		指定されたspeaker_uuidに関する情報をjson形式で返します。
	画像や音声はbase64エンコードされたものが返されます。

	Returns
	-------
	ret_data: SpeakerInfo

		@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
		@return OtherApiSpeakerInfoSpeakerInfoGetRequest
	*/
	SpeakerInfoSpeakerInfoGet(ctx context.Context) OtherApiSpeakerInfoSpeakerInfoGetRequest

	// SpeakerInfoSpeakerInfoGetExecute executes the request
	//  @return SpeakerInfo
	SpeakerInfoSpeakerInfoGetExecute(r OtherApiSpeakerInfoSpeakerInfoGetRequest) (*SpeakerInfo, *http.Response, error)

	/*
		SpeakersSpeakersGet Speakers

		@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
		@return OtherApiSpeakersSpeakersGetRequest
	*/
	SpeakersSpeakersGet(ctx context.Context) OtherApiSpeakersSpeakersGetRequest

	// SpeakersSpeakersGetExecute executes the request
	//  @return []Speaker
	SpeakersSpeakersGetExecute(r OtherApiSpeakersSpeakersGetRequest) ([]Speaker, *http.Response, error)

	/*
		SupportedDevicesSupportedDevicesGet Supported Devices

		@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
		@return OtherApiSupportedDevicesSupportedDevicesGetRequest
	*/
	SupportedDevicesSupportedDevicesGet(ctx context.Context) OtherApiSupportedDevicesSupportedDevicesGetRequest

	// SupportedDevicesSupportedDevicesGetExecute executes the request
	//  @return SupportedDevicesInfo
	SupportedDevicesSupportedDevicesGetExecute(r OtherApiSupportedDevicesSupportedDevicesGetRequest) (*SupportedDevicesInfo, *http.Response, error)

	/*
		UpdatePresetUpdatePresetPost Update Preset

		既存のプリセットを更新します

	Parameters
	-------
	preset: Preset
	    更新するプリセット。
	    プリセットIDが更新対象と一致している必要があります。

	Returns
	-------
	id: int
	    更新したプリセットのプリセットID

		@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
		@return OtherApiUpdatePresetUpdatePresetPostRequest
	*/
	UpdatePresetUpdatePresetPost(ctx context.Context) OtherApiUpdatePresetUpdatePresetPostRequest

	// UpdatePresetUpdatePresetPostExecute executes the request
	//  @return int32
	UpdatePresetUpdatePresetPostExecute(r OtherApiUpdatePresetUpdatePresetPostRequest) (int32, *http.Response, error)

	/*
		VersionVersionGet Version

		@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
		@return OtherApiVersionVersionGetRequest
	*/
	VersionVersionGet(ctx context.Context) OtherApiVersionVersionGetRequest

	// VersionVersionGetExecute executes the request
	//  @return interface{}
	VersionVersionGetExecute(r OtherApiVersionVersionGetRequest) (interface{}, *http.Response, error)
}

// OtherApiService OtherApi service
type OtherApiService service

type OtherApiAddPresetAddPresetPostRequest struct {
	ctx        context.Context
	ApiService OtherApi
	preset     *Preset
}

func (r OtherApiAddPresetAddPresetPostRequest) Preset(preset Preset) OtherApiAddPresetAddPresetPostRequest {
	r.preset = &preset
	return r
}

func (r OtherApiAddPresetAddPresetPostRequest) Execute() (int32, *http.Response, error) {
	return r.ApiService.AddPresetAddPresetPostExecute(r)
}

/*
AddPresetAddPresetPost Add Preset

新しいプリセットを追加します

Parameters
-------
preset: Preset

	新しいプリセット。
	プリセットIDが既存のものと重複している場合は、新規のプリセットIDが採番されます。

Returns
-------
id: int

	   追加したプリセットのプリセットID

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return OtherApiAddPresetAddPresetPostRequest
*/
func (a *OtherApiService) AddPresetAddPresetPost(ctx context.Context) OtherApiAddPresetAddPresetPostRequest {
	return OtherApiAddPresetAddPresetPostRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//
//	@return int32
func (a *OtherApiService) AddPresetAddPresetPostExecute(r OtherApiAddPresetAddPresetPostRequest) (int32, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPost
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue int32
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "OtherApiService.AddPresetAddPresetPost")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/add_preset"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.preset == nil {
		return localVarReturnValue, nil, reportError("preset is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.preset
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 422 {
			var v HTTPValidationError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type OtherApiConnectWavesConnectWavesPostRequest struct {
	ctx         context.Context
	ApiService  OtherApi
	requestBody *[]string
}

func (r OtherApiConnectWavesConnectWavesPostRequest) RequestBody(requestBody []string) OtherApiConnectWavesConnectWavesPostRequest {
	r.requestBody = &requestBody
	return r
}

func (r OtherApiConnectWavesConnectWavesPostRequest) Execute() (*os.File, *http.Response, error) {
	return r.ApiService.ConnectWavesConnectWavesPostExecute(r)
}

/*
ConnectWavesConnectWavesPost base64エンコードされた複数のwavデータを一つに結合する

base64エンコードされたwavデータを一纏めにし、wavファイルで返します。

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return OtherApiConnectWavesConnectWavesPostRequest
*/
func (a *OtherApiService) ConnectWavesConnectWavesPost(ctx context.Context) OtherApiConnectWavesConnectWavesPostRequest {
	return OtherApiConnectWavesConnectWavesPostRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//
//	@return *os.File
func (a *OtherApiService) ConnectWavesConnectWavesPostExecute(r OtherApiConnectWavesConnectWavesPostRequest) (*os.File, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPost
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *os.File
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "OtherApiService.ConnectWavesConnectWavesPost")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/connect_waves"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.requestBody == nil {
		return localVarReturnValue, nil, reportError("requestBody is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"audio/wav", "application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.requestBody
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 422 {
			var v HTTPValidationError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type OtherApiCoreVersionsCoreVersionsGetRequest struct {
	ctx        context.Context
	ApiService OtherApi
}

func (r OtherApiCoreVersionsCoreVersionsGetRequest) Execute() ([]string, *http.Response, error) {
	return r.ApiService.CoreVersionsCoreVersionsGetExecute(r)
}

/*
CoreVersionsCoreVersionsGet Core Versions

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return OtherApiCoreVersionsCoreVersionsGetRequest
*/
func (a *OtherApiService) CoreVersionsCoreVersionsGet(ctx context.Context) OtherApiCoreVersionsCoreVersionsGetRequest {
	return OtherApiCoreVersionsCoreVersionsGetRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//
//	@return []string
func (a *OtherApiService) CoreVersionsCoreVersionsGetExecute(r OtherApiCoreVersionsCoreVersionsGetRequest) ([]string, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue []string
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "OtherApiService.CoreVersionsCoreVersionsGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/core_versions"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type OtherApiDeletePresetDeletePresetPostRequest struct {
	ctx        context.Context
	ApiService OtherApi
	id         *int32
}

func (r OtherApiDeletePresetDeletePresetPostRequest) Id(id int32) OtherApiDeletePresetDeletePresetPostRequest {
	r.id = &id
	return r
}

func (r OtherApiDeletePresetDeletePresetPostRequest) Execute() (*http.Response, error) {
	return r.ApiService.DeletePresetDeletePresetPostExecute(r)
}

/*
DeletePresetDeletePresetPost Delete Preset

既存のプリセットを削除します

Parameters
-------
id: int

	   削除するプリセットのプリセットID

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return OtherApiDeletePresetDeletePresetPostRequest
*/
func (a *OtherApiService) DeletePresetDeletePresetPost(ctx context.Context) OtherApiDeletePresetDeletePresetPostRequest {
	return OtherApiDeletePresetDeletePresetPostRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
func (a *OtherApiService) DeletePresetDeletePresetPostExecute(r OtherApiDeletePresetDeletePresetPostRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod = http.MethodPost
		localVarPostBody   interface{}
		formFiles          []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "OtherApiService.DeletePresetDeletePresetPost")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/delete_preset"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.id == nil {
		return nil, reportError("id is required and must be specified")
	}

	parameterAddToHeaderOrQuery(localVarQueryParams, "id", r.id, "")
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 422 {
			var v HTTPValidationError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type OtherApiEngineManifestEngineManifestGetRequest struct {
	ctx        context.Context
	ApiService OtherApi
}

func (r OtherApiEngineManifestEngineManifestGetRequest) Execute() (*EngineManifest, *http.Response, error) {
	return r.ApiService.EngineManifestEngineManifestGetExecute(r)
}

/*
EngineManifestEngineManifestGet Engine Manifest

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return OtherApiEngineManifestEngineManifestGetRequest
*/
func (a *OtherApiService) EngineManifestEngineManifestGet(ctx context.Context) OtherApiEngineManifestEngineManifestGetRequest {
	return OtherApiEngineManifestEngineManifestGetRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//
//	@return EngineManifest
func (a *OtherApiService) EngineManifestEngineManifestGetExecute(r OtherApiEngineManifestEngineManifestGetRequest) (*EngineManifest, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *EngineManifest
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "OtherApiService.EngineManifestEngineManifestGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/engine_manifest"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type OtherApiGetPresetsPresetsGetRequest struct {
	ctx        context.Context
	ApiService OtherApi
}

func (r OtherApiGetPresetsPresetsGetRequest) Execute() ([]Preset, *http.Response, error) {
	return r.ApiService.GetPresetsPresetsGetExecute(r)
}

/*
GetPresetsPresetsGet Get Presets

エンジンが保持しているプリセットの設定を返します

Returns
-------
presets: List[Preset]

	   プリセットのリスト

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return OtherApiGetPresetsPresetsGetRequest
*/
func (a *OtherApiService) GetPresetsPresetsGet(ctx context.Context) OtherApiGetPresetsPresetsGetRequest {
	return OtherApiGetPresetsPresetsGetRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//
//	@return []Preset
func (a *OtherApiService) GetPresetsPresetsGetExecute(r OtherApiGetPresetsPresetsGetRequest) ([]Preset, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue []Preset
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "OtherApiService.GetPresetsPresetsGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/presets"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type OtherApiInitializeSpeakerInitializeSpeakerPostRequest struct {
	ctx         context.Context
	ApiService  OtherApi
	speaker     *int32
	skipReinit  *bool
	coreVersion *string
}

func (r OtherApiInitializeSpeakerInitializeSpeakerPostRequest) Speaker(speaker int32) OtherApiInitializeSpeakerInitializeSpeakerPostRequest {
	r.speaker = &speaker
	return r
}

// 既に初期化済みの話者の再初期化をスキップするかどうか
func (r OtherApiInitializeSpeakerInitializeSpeakerPostRequest) SkipReinit(skipReinit bool) OtherApiInitializeSpeakerInitializeSpeakerPostRequest {
	r.skipReinit = &skipReinit
	return r
}

func (r OtherApiInitializeSpeakerInitializeSpeakerPostRequest) CoreVersion(coreVersion string) OtherApiInitializeSpeakerInitializeSpeakerPostRequest {
	r.coreVersion = &coreVersion
	return r
}

func (r OtherApiInitializeSpeakerInitializeSpeakerPostRequest) Execute() (*http.Response, error) {
	return r.ApiService.InitializeSpeakerInitializeSpeakerPostExecute(r)
}

/*
InitializeSpeakerInitializeSpeakerPost Initialize Speaker

指定されたspeaker_idの話者を初期化します。
実行しなくても他のAPIは使用できますが、初回実行時に時間がかかることがあります。

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return OtherApiInitializeSpeakerInitializeSpeakerPostRequest
*/
func (a *OtherApiService) InitializeSpeakerInitializeSpeakerPost(ctx context.Context) OtherApiInitializeSpeakerInitializeSpeakerPostRequest {
	return OtherApiInitializeSpeakerInitializeSpeakerPostRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
func (a *OtherApiService) InitializeSpeakerInitializeSpeakerPostExecute(r OtherApiInitializeSpeakerInitializeSpeakerPostRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod = http.MethodPost
		localVarPostBody   interface{}
		formFiles          []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "OtherApiService.InitializeSpeakerInitializeSpeakerPost")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/initialize_speaker"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.speaker == nil {
		return nil, reportError("speaker is required and must be specified")
	}

	parameterAddToHeaderOrQuery(localVarQueryParams, "speaker", r.speaker, "")
	if r.skipReinit != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "skip_reinit", r.skipReinit, "")
	}
	if r.coreVersion != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "core_version", r.coreVersion, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 422 {
			var v HTTPValidationError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type OtherApiIsInitializedSpeakerIsInitializedSpeakerGetRequest struct {
	ctx         context.Context
	ApiService  OtherApi
	speaker     *int32
	coreVersion *string
}

func (r OtherApiIsInitializedSpeakerIsInitializedSpeakerGetRequest) Speaker(speaker int32) OtherApiIsInitializedSpeakerIsInitializedSpeakerGetRequest {
	r.speaker = &speaker
	return r
}

func (r OtherApiIsInitializedSpeakerIsInitializedSpeakerGetRequest) CoreVersion(coreVersion string) OtherApiIsInitializedSpeakerIsInitializedSpeakerGetRequest {
	r.coreVersion = &coreVersion
	return r
}

func (r OtherApiIsInitializedSpeakerIsInitializedSpeakerGetRequest) Execute() (bool, *http.Response, error) {
	return r.ApiService.IsInitializedSpeakerIsInitializedSpeakerGetExecute(r)
}

/*
IsInitializedSpeakerIsInitializedSpeakerGet Is Initialized Speaker

指定されたspeaker_idの話者が初期化されているかどうかを返します。

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return OtherApiIsInitializedSpeakerIsInitializedSpeakerGetRequest
*/
func (a *OtherApiService) IsInitializedSpeakerIsInitializedSpeakerGet(ctx context.Context) OtherApiIsInitializedSpeakerIsInitializedSpeakerGetRequest {
	return OtherApiIsInitializedSpeakerIsInitializedSpeakerGetRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//
//	@return bool
func (a *OtherApiService) IsInitializedSpeakerIsInitializedSpeakerGetExecute(r OtherApiIsInitializedSpeakerIsInitializedSpeakerGetRequest) (bool, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue bool
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "OtherApiService.IsInitializedSpeakerIsInitializedSpeakerGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/is_initialized_speaker"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.speaker == nil {
		return localVarReturnValue, nil, reportError("speaker is required and must be specified")
	}

	parameterAddToHeaderOrQuery(localVarQueryParams, "speaker", r.speaker, "")
	if r.coreVersion != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "core_version", r.coreVersion, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 422 {
			var v HTTPValidationError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type OtherApiSpeakerInfoSpeakerInfoGetRequest struct {
	ctx         context.Context
	ApiService  OtherApi
	speakerUuid *string
	coreVersion *string
}

func (r OtherApiSpeakerInfoSpeakerInfoGetRequest) SpeakerUuid(speakerUuid string) OtherApiSpeakerInfoSpeakerInfoGetRequest {
	r.speakerUuid = &speakerUuid
	return r
}

func (r OtherApiSpeakerInfoSpeakerInfoGetRequest) CoreVersion(coreVersion string) OtherApiSpeakerInfoSpeakerInfoGetRequest {
	r.coreVersion = &coreVersion
	return r
}

func (r OtherApiSpeakerInfoSpeakerInfoGetRequest) Execute() (*SpeakerInfo, *http.Response, error) {
	return r.ApiService.SpeakerInfoSpeakerInfoGetExecute(r)
}

/*
SpeakerInfoSpeakerInfoGet Speaker Info

指定されたspeaker_uuidに関する情報をjson形式で返します。
画像や音声はbase64エンコードされたものが返されます。

Returns
-------
ret_data: SpeakerInfo

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return OtherApiSpeakerInfoSpeakerInfoGetRequest
*/
func (a *OtherApiService) SpeakerInfoSpeakerInfoGet(ctx context.Context) OtherApiSpeakerInfoSpeakerInfoGetRequest {
	return OtherApiSpeakerInfoSpeakerInfoGetRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//
//	@return SpeakerInfo
func (a *OtherApiService) SpeakerInfoSpeakerInfoGetExecute(r OtherApiSpeakerInfoSpeakerInfoGetRequest) (*SpeakerInfo, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *SpeakerInfo
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "OtherApiService.SpeakerInfoSpeakerInfoGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/speaker_info"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.speakerUuid == nil {
		return localVarReturnValue, nil, reportError("speakerUuid is required and must be specified")
	}

	parameterAddToHeaderOrQuery(localVarQueryParams, "speaker_uuid", r.speakerUuid, "")
	if r.coreVersion != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "core_version", r.coreVersion, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 422 {
			var v HTTPValidationError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type OtherApiSpeakersSpeakersGetRequest struct {
	ctx         context.Context
	ApiService  OtherApi
	coreVersion *string
}

func (r OtherApiSpeakersSpeakersGetRequest) CoreVersion(coreVersion string) OtherApiSpeakersSpeakersGetRequest {
	r.coreVersion = &coreVersion
	return r
}

func (r OtherApiSpeakersSpeakersGetRequest) Execute() ([]Speaker, *http.Response, error) {
	return r.ApiService.SpeakersSpeakersGetExecute(r)
}

/*
SpeakersSpeakersGet Speakers

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return OtherApiSpeakersSpeakersGetRequest
*/
func (a *OtherApiService) SpeakersSpeakersGet(ctx context.Context) OtherApiSpeakersSpeakersGetRequest {
	return OtherApiSpeakersSpeakersGetRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//
//	@return []Speaker
func (a *OtherApiService) SpeakersSpeakersGetExecute(r OtherApiSpeakersSpeakersGetRequest) ([]Speaker, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue []Speaker
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "OtherApiService.SpeakersSpeakersGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/speakers"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.coreVersion != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "core_version", r.coreVersion, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 422 {
			var v HTTPValidationError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type OtherApiSupportedDevicesSupportedDevicesGetRequest struct {
	ctx         context.Context
	ApiService  OtherApi
	coreVersion *string
}

func (r OtherApiSupportedDevicesSupportedDevicesGetRequest) CoreVersion(coreVersion string) OtherApiSupportedDevicesSupportedDevicesGetRequest {
	r.coreVersion = &coreVersion
	return r
}

func (r OtherApiSupportedDevicesSupportedDevicesGetRequest) Execute() (*SupportedDevicesInfo, *http.Response, error) {
	return r.ApiService.SupportedDevicesSupportedDevicesGetExecute(r)
}

/*
SupportedDevicesSupportedDevicesGet Supported Devices

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return OtherApiSupportedDevicesSupportedDevicesGetRequest
*/
func (a *OtherApiService) SupportedDevicesSupportedDevicesGet(ctx context.Context) OtherApiSupportedDevicesSupportedDevicesGetRequest {
	return OtherApiSupportedDevicesSupportedDevicesGetRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//
//	@return SupportedDevicesInfo
func (a *OtherApiService) SupportedDevicesSupportedDevicesGetExecute(r OtherApiSupportedDevicesSupportedDevicesGetRequest) (*SupportedDevicesInfo, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *SupportedDevicesInfo
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "OtherApiService.SupportedDevicesSupportedDevicesGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/supported_devices"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.coreVersion != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "core_version", r.coreVersion, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 422 {
			var v HTTPValidationError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type OtherApiUpdatePresetUpdatePresetPostRequest struct {
	ctx        context.Context
	ApiService OtherApi
	preset     *Preset
}

func (r OtherApiUpdatePresetUpdatePresetPostRequest) Preset(preset Preset) OtherApiUpdatePresetUpdatePresetPostRequest {
	r.preset = &preset
	return r
}

func (r OtherApiUpdatePresetUpdatePresetPostRequest) Execute() (int32, *http.Response, error) {
	return r.ApiService.UpdatePresetUpdatePresetPostExecute(r)
}

/*
UpdatePresetUpdatePresetPost Update Preset

既存のプリセットを更新します

Parameters
-------
preset: Preset

	更新するプリセット。
	プリセットIDが更新対象と一致している必要があります。

Returns
-------
id: int

	   更新したプリセットのプリセットID

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return OtherApiUpdatePresetUpdatePresetPostRequest
*/
func (a *OtherApiService) UpdatePresetUpdatePresetPost(ctx context.Context) OtherApiUpdatePresetUpdatePresetPostRequest {
	return OtherApiUpdatePresetUpdatePresetPostRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//
//	@return int32
func (a *OtherApiService) UpdatePresetUpdatePresetPostExecute(r OtherApiUpdatePresetUpdatePresetPostRequest) (int32, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPost
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue int32
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "OtherApiService.UpdatePresetUpdatePresetPost")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/update_preset"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.preset == nil {
		return localVarReturnValue, nil, reportError("preset is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.preset
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 422 {
			var v HTTPValidationError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type OtherApiVersionVersionGetRequest struct {
	ctx        context.Context
	ApiService OtherApi
}

func (r OtherApiVersionVersionGetRequest) Execute() (interface{}, *http.Response, error) {
	return r.ApiService.VersionVersionGetExecute(r)
}

/*
VersionVersionGet Version

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return OtherApiVersionVersionGetRequest
*/
func (a *OtherApiService) VersionVersionGet(ctx context.Context) OtherApiVersionVersionGetRequest {
	return OtherApiVersionVersionGetRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//
//	@return interface{}
func (a *OtherApiService) VersionVersionGetExecute(r OtherApiVersionVersionGetRequest) (interface{}, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue interface{}
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "OtherApiService.VersionVersionGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/version"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}
