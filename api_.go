/*
VOICEVOX Engine

VOICEVOXの音声合成エンジンです。

API version: latest
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package voicevox

import (
	"bytes"
	"context"
	"io"
	"net/http"
	"net/url"
	"os"
	"strings"
)

// DefaultApiService DefaultApi service
type DefaultApiService service

type ApiAccentPhrasesAccentPhrasesPostRequest struct {
	ctx         context.Context
	ApiService  *DefaultApiService
	text        *string
	speaker     *int32
	isKana      *bool
	coreVersion *string
}

func (r ApiAccentPhrasesAccentPhrasesPostRequest) Text(text string) ApiAccentPhrasesAccentPhrasesPostRequest {
	r.text = &text
	return r
}

func (r ApiAccentPhrasesAccentPhrasesPostRequest) Speaker(speaker int32) ApiAccentPhrasesAccentPhrasesPostRequest {
	r.speaker = &speaker
	return r
}

func (r ApiAccentPhrasesAccentPhrasesPostRequest) IsKana(isKana bool) ApiAccentPhrasesAccentPhrasesPostRequest {
	r.isKana = &isKana
	return r
}

func (r ApiAccentPhrasesAccentPhrasesPostRequest) CoreVersion(coreVersion string) ApiAccentPhrasesAccentPhrasesPostRequest {
	r.coreVersion = &coreVersion
	return r
}

func (r ApiAccentPhrasesAccentPhrasesPostRequest) Execute() ([]AccentPhrase, *http.Response, error) {
	return r.ApiService.AccentPhrasesAccentPhrasesPostExecute(r)
}

/*
AccentPhrasesAccentPhrasesPost テキストからアクセント句を得る

テキストからアクセント句を得ます。
is_kanaが`true`のとき、テキストは次のようなAquesTalkライクな記法に従う読み仮名として処理されます。デフォルトは`false`です。
* 全てのカナはカタカナで記述される
* アクセント句は`/`または`、`で区切る。`、`で区切った場合に限り無音区間が挿入される。
* カナの手前に`_`を入れるとそのカナは無声化される
* アクセント位置を`'`で指定する。全てのアクセント句にはアクセント位置を1つ指定する必要がある。
* アクセント句末に`？`(全角)を入れることにより疑問文の発音ができる。

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiAccentPhrasesAccentPhrasesPostRequest
*/
func (a *DefaultApiService) AccentPhrasesAccentPhrasesPost(ctx context.Context) ApiAccentPhrasesAccentPhrasesPostRequest {
	return ApiAccentPhrasesAccentPhrasesPostRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//
//	@return []AccentPhrase
func (a *DefaultApiService) AccentPhrasesAccentPhrasesPostExecute(r ApiAccentPhrasesAccentPhrasesPostRequest) ([]AccentPhrase, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPost
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue []AccentPhrase
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultApiService.AccentPhrasesAccentPhrasesPost")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/accent_phrases"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.text == nil {
		return localVarReturnValue, nil, reportError("text is required and must be specified")
	}
	if r.speaker == nil {
		return localVarReturnValue, nil, reportError("speaker is required and must be specified")
	}

	parameterAddToHeaderOrQuery(localVarQueryParams, "text", r.text, "")
	parameterAddToHeaderOrQuery(localVarQueryParams, "speaker", r.speaker, "")
	if r.isKana != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "is_kana", r.isKana, "")
	}
	if r.coreVersion != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "core_version", r.coreVersion, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ParseKanaBadRequest
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 422 {
			var v HTTPValidationError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiAddPresetAddPresetPostRequest struct {
	ctx        context.Context
	ApiService *DefaultApiService
	preset     *Preset
}

func (r ApiAddPresetAddPresetPostRequest) Preset(preset Preset) ApiAddPresetAddPresetPostRequest {
	r.preset = &preset
	return r
}

func (r ApiAddPresetAddPresetPostRequest) Execute() (int32, *http.Response, error) {
	return r.ApiService.AddPresetAddPresetPostExecute(r)
}

/*
AddPresetAddPresetPost Add Preset

新しいプリセットを追加します

Parameters
-------
preset: Preset

	新しいプリセット。
	プリセットIDが既存のものと重複している場合は、新規のプリセットIDが採番されます。

Returns
-------
id: int

	   追加したプリセットのプリセットID

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiAddPresetAddPresetPostRequest
*/
func (a *DefaultApiService) AddPresetAddPresetPost(ctx context.Context) ApiAddPresetAddPresetPostRequest {
	return ApiAddPresetAddPresetPostRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//
//	@return int32
func (a *DefaultApiService) AddPresetAddPresetPostExecute(r ApiAddPresetAddPresetPostRequest) (int32, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPost
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue int32
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultApiService.AddPresetAddPresetPost")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/add_preset"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.preset == nil {
		return localVarReturnValue, nil, reportError("preset is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.preset
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 422 {
			var v HTTPValidationError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiAddUserDictWordUserDictWordPostRequest struct {
	ctx           context.Context
	ApiService    *DefaultApiService
	surface       *string
	pronunciation *string
	accentType    *int32
	wordType      *WordTypes
	priority      *int32
}

func (r ApiAddUserDictWordUserDictWordPostRequest) Surface(surface string) ApiAddUserDictWordUserDictWordPostRequest {
	r.surface = &surface
	return r
}

func (r ApiAddUserDictWordUserDictWordPostRequest) Pronunciation(pronunciation string) ApiAddUserDictWordUserDictWordPostRequest {
	r.pronunciation = &pronunciation
	return r
}

func (r ApiAddUserDictWordUserDictWordPostRequest) AccentType(accentType int32) ApiAddUserDictWordUserDictWordPostRequest {
	r.accentType = &accentType
	return r
}

func (r ApiAddUserDictWordUserDictWordPostRequest) WordType(wordType WordTypes) ApiAddUserDictWordUserDictWordPostRequest {
	r.wordType = &wordType
	return r
}

func (r ApiAddUserDictWordUserDictWordPostRequest) Priority(priority int32) ApiAddUserDictWordUserDictWordPostRequest {
	r.priority = &priority
	return r
}

func (r ApiAddUserDictWordUserDictWordPostRequest) Execute() (string, *http.Response, error) {
	return r.ApiService.AddUserDictWordUserDictWordPostExecute(r)
}

/*
AddUserDictWordUserDictWordPost Add User Dict Word

ユーザー辞書に言葉を追加します。

Parameters
----------
surface : str

	言葉の表層形

pronunciation: str

	言葉の発音（カタカナ）

accent_type: int

	アクセント型（音が下がる場所を指す）

word_type: WordTypes, optional

	PROPER_NOUN（固有名詞）、COMMON_NOUN（普通名詞）、VERB（動詞）、ADJECTIVE（形容詞）、SUFFIX（語尾）のいずれか

priority: int, optional

	   単語の優先度（0から10までの整数）
	   数字が大きいほど優先度が高くなる
	   1から9までの値を指定することを推奨

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiAddUserDictWordUserDictWordPostRequest
*/
func (a *DefaultApiService) AddUserDictWordUserDictWordPost(ctx context.Context) ApiAddUserDictWordUserDictWordPostRequest {
	return ApiAddUserDictWordUserDictWordPostRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//
//	@return string
func (a *DefaultApiService) AddUserDictWordUserDictWordPostExecute(r ApiAddUserDictWordUserDictWordPostRequest) (string, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPost
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue string
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultApiService.AddUserDictWordUserDictWordPost")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/user_dict_word"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.surface == nil {
		return localVarReturnValue, nil, reportError("surface is required and must be specified")
	}
	if r.pronunciation == nil {
		return localVarReturnValue, nil, reportError("pronunciation is required and must be specified")
	}
	if r.accentType == nil {
		return localVarReturnValue, nil, reportError("accentType is required and must be specified")
	}

	parameterAddToHeaderOrQuery(localVarQueryParams, "surface", r.surface, "")
	parameterAddToHeaderOrQuery(localVarQueryParams, "pronunciation", r.pronunciation, "")
	parameterAddToHeaderOrQuery(localVarQueryParams, "accent_type", r.accentType, "")
	if r.wordType != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "word_type", r.wordType, "")
	}
	if r.priority != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "priority", r.priority, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 422 {
			var v HTTPValidationError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiAudioQueryAudioQueryPostRequest struct {
	ctx         context.Context
	ApiService  *DefaultApiService
	text        *string
	speaker     *int32
	coreVersion *string
}

func (r ApiAudioQueryAudioQueryPostRequest) Text(text string) ApiAudioQueryAudioQueryPostRequest {
	r.text = &text
	return r
}

func (r ApiAudioQueryAudioQueryPostRequest) Speaker(speaker int32) ApiAudioQueryAudioQueryPostRequest {
	r.speaker = &speaker
	return r
}

func (r ApiAudioQueryAudioQueryPostRequest) CoreVersion(coreVersion string) ApiAudioQueryAudioQueryPostRequest {
	r.coreVersion = &coreVersion
	return r
}

func (r ApiAudioQueryAudioQueryPostRequest) Execute() (*AudioQuery, *http.Response, error) {
	return r.ApiService.AudioQueryAudioQueryPostExecute(r)
}

/*
AudioQueryAudioQueryPost 音声合成用のクエリを作成する

クエリの初期値を得ます。ここで得られたクエリはそのまま音声合成に利用できます。各値の意味は`Schemas`を参照してください。

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiAudioQueryAudioQueryPostRequest
*/
func (a *DefaultApiService) AudioQueryAudioQueryPost(ctx context.Context) ApiAudioQueryAudioQueryPostRequest {
	return ApiAudioQueryAudioQueryPostRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//
//	@return AudioQuery
func (a *DefaultApiService) AudioQueryAudioQueryPostExecute(r ApiAudioQueryAudioQueryPostRequest) (*AudioQuery, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPost
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *AudioQuery
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultApiService.AudioQueryAudioQueryPost")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/audio_query"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.text == nil {
		return localVarReturnValue, nil, reportError("text is required and must be specified")
	}
	if r.speaker == nil {
		return localVarReturnValue, nil, reportError("speaker is required and must be specified")
	}

	parameterAddToHeaderOrQuery(localVarQueryParams, "text", r.text, "")
	parameterAddToHeaderOrQuery(localVarQueryParams, "speaker", r.speaker, "")
	if r.coreVersion != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "core_version", r.coreVersion, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 422 {
			var v HTTPValidationError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiAudioQueryFromPresetAudioQueryFromPresetPostRequest struct {
	ctx         context.Context
	ApiService  *DefaultApiService
	text        *string
	presetId    *int32
	coreVersion *string
}

func (r ApiAudioQueryFromPresetAudioQueryFromPresetPostRequest) Text(text string) ApiAudioQueryFromPresetAudioQueryFromPresetPostRequest {
	r.text = &text
	return r
}

func (r ApiAudioQueryFromPresetAudioQueryFromPresetPostRequest) PresetId(presetId int32) ApiAudioQueryFromPresetAudioQueryFromPresetPostRequest {
	r.presetId = &presetId
	return r
}

func (r ApiAudioQueryFromPresetAudioQueryFromPresetPostRequest) CoreVersion(coreVersion string) ApiAudioQueryFromPresetAudioQueryFromPresetPostRequest {
	r.coreVersion = &coreVersion
	return r
}

func (r ApiAudioQueryFromPresetAudioQueryFromPresetPostRequest) Execute() (*AudioQuery, *http.Response, error) {
	return r.ApiService.AudioQueryFromPresetAudioQueryFromPresetPostExecute(r)
}

/*
AudioQueryFromPresetAudioQueryFromPresetPost 音声合成用のクエリをプリセットを用いて作成する

クエリの初期値を得ます。ここで得られたクエリはそのまま音声合成に利用できます。各値の意味は`Schemas`を参照してください。

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiAudioQueryFromPresetAudioQueryFromPresetPostRequest
*/
func (a *DefaultApiService) AudioQueryFromPresetAudioQueryFromPresetPost(ctx context.Context) ApiAudioQueryFromPresetAudioQueryFromPresetPostRequest {
	return ApiAudioQueryFromPresetAudioQueryFromPresetPostRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//
//	@return AudioQuery
func (a *DefaultApiService) AudioQueryFromPresetAudioQueryFromPresetPostExecute(r ApiAudioQueryFromPresetAudioQueryFromPresetPostRequest) (*AudioQuery, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPost
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *AudioQuery
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultApiService.AudioQueryFromPresetAudioQueryFromPresetPost")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/audio_query_from_preset"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.text == nil {
		return localVarReturnValue, nil, reportError("text is required and must be specified")
	}
	if r.presetId == nil {
		return localVarReturnValue, nil, reportError("presetId is required and must be specified")
	}

	parameterAddToHeaderOrQuery(localVarQueryParams, "text", r.text, "")
	parameterAddToHeaderOrQuery(localVarQueryParams, "preset_id", r.presetId, "")
	if r.coreVersion != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "core_version", r.coreVersion, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 422 {
			var v HTTPValidationError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiCancellableSynthesisCancellableSynthesisPostRequest struct {
	ctx         context.Context
	ApiService  *DefaultApiService
	speaker     *int32
	audioQuery  *AudioQuery
	coreVersion *string
}

func (r ApiCancellableSynthesisCancellableSynthesisPostRequest) Speaker(speaker int32) ApiCancellableSynthesisCancellableSynthesisPostRequest {
	r.speaker = &speaker
	return r
}

func (r ApiCancellableSynthesisCancellableSynthesisPostRequest) AudioQuery(audioQuery AudioQuery) ApiCancellableSynthesisCancellableSynthesisPostRequest {
	r.audioQuery = &audioQuery
	return r
}

func (r ApiCancellableSynthesisCancellableSynthesisPostRequest) CoreVersion(coreVersion string) ApiCancellableSynthesisCancellableSynthesisPostRequest {
	r.coreVersion = &coreVersion
	return r
}

func (r ApiCancellableSynthesisCancellableSynthesisPostRequest) Execute() (*os.File, *http.Response, error) {
	return r.ApiService.CancellableSynthesisCancellableSynthesisPostExecute(r)
}

/*
CancellableSynthesisCancellableSynthesisPost 音声合成する（キャンセル可能）

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiCancellableSynthesisCancellableSynthesisPostRequest
*/
func (a *DefaultApiService) CancellableSynthesisCancellableSynthesisPost(ctx context.Context) ApiCancellableSynthesisCancellableSynthesisPostRequest {
	return ApiCancellableSynthesisCancellableSynthesisPostRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//
//	@return *os.File
func (a *DefaultApiService) CancellableSynthesisCancellableSynthesisPostExecute(r ApiCancellableSynthesisCancellableSynthesisPostRequest) (*os.File, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPost
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *os.File
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultApiService.CancellableSynthesisCancellableSynthesisPost")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/cancellable_synthesis"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.speaker == nil {
		return localVarReturnValue, nil, reportError("speaker is required and must be specified")
	}
	if r.audioQuery == nil {
		return localVarReturnValue, nil, reportError("audioQuery is required and must be specified")
	}

	parameterAddToHeaderOrQuery(localVarQueryParams, "speaker", r.speaker, "")
	if r.coreVersion != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "core_version", r.coreVersion, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"audio/wav", "application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.audioQuery
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 422 {
			var v HTTPValidationError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiConnectWavesConnectWavesPostRequest struct {
	ctx         context.Context
	ApiService  *DefaultApiService
	requestBody *[]string
}

func (r ApiConnectWavesConnectWavesPostRequest) RequestBody(requestBody []string) ApiConnectWavesConnectWavesPostRequest {
	r.requestBody = &requestBody
	return r
}

func (r ApiConnectWavesConnectWavesPostRequest) Execute() (*os.File, *http.Response, error) {
	return r.ApiService.ConnectWavesConnectWavesPostExecute(r)
}

/*
ConnectWavesConnectWavesPost base64エンコードされた複数のwavデータを一つに結合する

base64エンコードされたwavデータを一纏めにし、wavファイルで返します。

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiConnectWavesConnectWavesPostRequest
*/
func (a *DefaultApiService) ConnectWavesConnectWavesPost(ctx context.Context) ApiConnectWavesConnectWavesPostRequest {
	return ApiConnectWavesConnectWavesPostRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//
//	@return *os.File
func (a *DefaultApiService) ConnectWavesConnectWavesPostExecute(r ApiConnectWavesConnectWavesPostRequest) (*os.File, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPost
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *os.File
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultApiService.ConnectWavesConnectWavesPost")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/connect_waves"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.requestBody == nil {
		return localVarReturnValue, nil, reportError("requestBody is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"audio/wav", "application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.requestBody
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 422 {
			var v HTTPValidationError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiCoreVersionsCoreVersionsGetRequest struct {
	ctx        context.Context
	ApiService *DefaultApiService
}

func (r ApiCoreVersionsCoreVersionsGetRequest) Execute() ([]string, *http.Response, error) {
	return r.ApiService.CoreVersionsCoreVersionsGetExecute(r)
}

/*
CoreVersionsCoreVersionsGet Core Versions

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiCoreVersionsCoreVersionsGetRequest
*/
func (a *DefaultApiService) CoreVersionsCoreVersionsGet(ctx context.Context) ApiCoreVersionsCoreVersionsGetRequest {
	return ApiCoreVersionsCoreVersionsGetRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//
//	@return []string
func (a *DefaultApiService) CoreVersionsCoreVersionsGetExecute(r ApiCoreVersionsCoreVersionsGetRequest) ([]string, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue []string
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultApiService.CoreVersionsCoreVersionsGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/core_versions"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiDeletePresetDeletePresetPostRequest struct {
	ctx        context.Context
	ApiService *DefaultApiService
	id         *int32
}

func (r ApiDeletePresetDeletePresetPostRequest) Id(id int32) ApiDeletePresetDeletePresetPostRequest {
	r.id = &id
	return r
}

func (r ApiDeletePresetDeletePresetPostRequest) Execute() (*http.Response, error) {
	return r.ApiService.DeletePresetDeletePresetPostExecute(r)
}

/*
DeletePresetDeletePresetPost Delete Preset

既存のプリセットを削除します

Parameters
-------
id: int

	   削除するプリセットのプリセットID

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiDeletePresetDeletePresetPostRequest
*/
func (a *DefaultApiService) DeletePresetDeletePresetPost(ctx context.Context) ApiDeletePresetDeletePresetPostRequest {
	return ApiDeletePresetDeletePresetPostRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
func (a *DefaultApiService) DeletePresetDeletePresetPostExecute(r ApiDeletePresetDeletePresetPostRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod = http.MethodPost
		localVarPostBody   interface{}
		formFiles          []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultApiService.DeletePresetDeletePresetPost")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/delete_preset"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.id == nil {
		return nil, reportError("id is required and must be specified")
	}

	parameterAddToHeaderOrQuery(localVarQueryParams, "id", r.id, "")
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 422 {
			var v HTTPValidationError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiDeleteUserDictWordUserDictWordWordUuidDeleteRequest struct {
	ctx        context.Context
	ApiService *DefaultApiService
	wordUuid   string
}

func (r ApiDeleteUserDictWordUserDictWordWordUuidDeleteRequest) Execute() (*http.Response, error) {
	return r.ApiService.DeleteUserDictWordUserDictWordWordUuidDeleteExecute(r)
}

/*
DeleteUserDictWordUserDictWordWordUuidDelete Delete User Dict Word

ユーザー辞書に登録されている言葉を削除します。

Parameters
----------
word_uuid: str

	   削除する言葉のUUID

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param wordUuid
	@return ApiDeleteUserDictWordUserDictWordWordUuidDeleteRequest
*/
func (a *DefaultApiService) DeleteUserDictWordUserDictWordWordUuidDelete(ctx context.Context, wordUuid string) ApiDeleteUserDictWordUserDictWordWordUuidDeleteRequest {
	return ApiDeleteUserDictWordUserDictWordWordUuidDeleteRequest{
		ApiService: a,
		ctx:        ctx,
		wordUuid:   wordUuid,
	}
}

// Execute executes the request
func (a *DefaultApiService) DeleteUserDictWordUserDictWordWordUuidDeleteExecute(r ApiDeleteUserDictWordUserDictWordWordUuidDeleteRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod = http.MethodDelete
		localVarPostBody   interface{}
		formFiles          []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultApiService.DeleteUserDictWordUserDictWordWordUuidDelete")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/user_dict_word/{word_uuid}"
	localVarPath = strings.Replace(localVarPath, "{"+"word_uuid"+"}", url.PathEscape(parameterValueToString(r.wordUuid, "wordUuid")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 422 {
			var v HTTPValidationError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiDownloadableLibrariesDownloadableLibrariesGetRequest struct {
	ctx        context.Context
	ApiService *DefaultApiService
}

func (r ApiDownloadableLibrariesDownloadableLibrariesGetRequest) Execute() ([]DownloadableLibrary, *http.Response, error) {
	return r.ApiService.DownloadableLibrariesDownloadableLibrariesGetExecute(r)
}

/*
DownloadableLibrariesDownloadableLibrariesGet Downloadable Libraries

ダウンロード可能な音声ライブラリの情報を返します。

Returns
-------
ret_data: List[DownloadableLibrary]

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiDownloadableLibrariesDownloadableLibrariesGetRequest
*/
func (a *DefaultApiService) DownloadableLibrariesDownloadableLibrariesGet(ctx context.Context) ApiDownloadableLibrariesDownloadableLibrariesGetRequest {
	return ApiDownloadableLibrariesDownloadableLibrariesGetRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//
//	@return []DownloadableLibrary
func (a *DefaultApiService) DownloadableLibrariesDownloadableLibrariesGetExecute(r ApiDownloadableLibrariesDownloadableLibrariesGetRequest) ([]DownloadableLibrary, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue []DownloadableLibrary
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultApiService.DownloadableLibrariesDownloadableLibrariesGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/downloadable_libraries"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiEngineManifestEngineManifestGetRequest struct {
	ctx        context.Context
	ApiService *DefaultApiService
}

func (r ApiEngineManifestEngineManifestGetRequest) Execute() (*EngineManifest, *http.Response, error) {
	return r.ApiService.EngineManifestEngineManifestGetExecute(r)
}

/*
EngineManifestEngineManifestGet Engine Manifest

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiEngineManifestEngineManifestGetRequest
*/
func (a *DefaultApiService) EngineManifestEngineManifestGet(ctx context.Context) ApiEngineManifestEngineManifestGetRequest {
	return ApiEngineManifestEngineManifestGetRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//
//	@return EngineManifest
func (a *DefaultApiService) EngineManifestEngineManifestGetExecute(r ApiEngineManifestEngineManifestGetRequest) (*EngineManifest, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *EngineManifest
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultApiService.EngineManifestEngineManifestGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/engine_manifest"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetPresetsPresetsGetRequest struct {
	ctx        context.Context
	ApiService *DefaultApiService
}

func (r ApiGetPresetsPresetsGetRequest) Execute() ([]Preset, *http.Response, error) {
	return r.ApiService.GetPresetsPresetsGetExecute(r)
}

/*
GetPresetsPresetsGet Get Presets

エンジンが保持しているプリセットの設定を返します

Returns
-------
presets: List[Preset]

	   プリセットのリスト

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiGetPresetsPresetsGetRequest
*/
func (a *DefaultApiService) GetPresetsPresetsGet(ctx context.Context) ApiGetPresetsPresetsGetRequest {
	return ApiGetPresetsPresetsGetRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//
//	@return []Preset
func (a *DefaultApiService) GetPresetsPresetsGetExecute(r ApiGetPresetsPresetsGetRequest) ([]Preset, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue []Preset
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultApiService.GetPresetsPresetsGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/presets"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetUserDictWordsUserDictGetRequest struct {
	ctx        context.Context
	ApiService *DefaultApiService
}

func (r ApiGetUserDictWordsUserDictGetRequest) Execute() (*map[string]UserDictWord, *http.Response, error) {
	return r.ApiService.GetUserDictWordsUserDictGetExecute(r)
}

/*
GetUserDictWordsUserDictGet Get User Dict Words

ユーザー辞書に登録されている単語の一覧を返します。
単語の表層形(surface)は正規化済みの物を返します。

Returns
-------
Dict[str, UserDictWord]

	   単語のUUIDとその詳細

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiGetUserDictWordsUserDictGetRequest
*/
func (a *DefaultApiService) GetUserDictWordsUserDictGet(ctx context.Context) ApiGetUserDictWordsUserDictGetRequest {
	return ApiGetUserDictWordsUserDictGetRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//
//	@return map[string]UserDictWord
func (a *DefaultApiService) GetUserDictWordsUserDictGetExecute(r ApiGetUserDictWordsUserDictGetRequest) (*map[string]UserDictWord, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *map[string]UserDictWord
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultApiService.GetUserDictWordsUserDictGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/user_dict"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiImportUserDictWordsImportUserDictPostRequest struct {
	ctx         context.Context
	ApiService  *DefaultApiService
	override    *bool
	requestBody *map[string]UserDictWord
}

func (r ApiImportUserDictWordsImportUserDictPostRequest) Override(override bool) ApiImportUserDictWordsImportUserDictPostRequest {
	r.override = &override
	return r
}

func (r ApiImportUserDictWordsImportUserDictPostRequest) RequestBody(requestBody map[string]UserDictWord) ApiImportUserDictWordsImportUserDictPostRequest {
	r.requestBody = &requestBody
	return r
}

func (r ApiImportUserDictWordsImportUserDictPostRequest) Execute() (*http.Response, error) {
	return r.ApiService.ImportUserDictWordsImportUserDictPostExecute(r)
}

/*
ImportUserDictWordsImportUserDictPost Import User Dict Words

他のユーザー辞書をインポートします。

Parameters
----------
import_dict_data: Dict[str, UserDictWord]

	インポートするユーザー辞書のデータ

override: bool

	   重複したエントリがあった場合、上書きするかどうか

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiImportUserDictWordsImportUserDictPostRequest
*/
func (a *DefaultApiService) ImportUserDictWordsImportUserDictPost(ctx context.Context) ApiImportUserDictWordsImportUserDictPostRequest {
	return ApiImportUserDictWordsImportUserDictPostRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
func (a *DefaultApiService) ImportUserDictWordsImportUserDictPostExecute(r ApiImportUserDictWordsImportUserDictPostRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod = http.MethodPost
		localVarPostBody   interface{}
		formFiles          []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultApiService.ImportUserDictWordsImportUserDictPost")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/import_user_dict"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.override == nil {
		return nil, reportError("override is required and must be specified")
	}
	if r.requestBody == nil {
		return nil, reportError("requestBody is required and must be specified")
	}

	parameterAddToHeaderOrQuery(localVarQueryParams, "override", r.override, "")
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.requestBody
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 422 {
			var v HTTPValidationError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiInitializeSpeakerInitializeSpeakerPostRequest struct {
	ctx         context.Context
	ApiService  *DefaultApiService
	speaker     *int32
	skipReinit  *bool
	coreVersion *string
}

func (r ApiInitializeSpeakerInitializeSpeakerPostRequest) Speaker(speaker int32) ApiInitializeSpeakerInitializeSpeakerPostRequest {
	r.speaker = &speaker
	return r
}

// 既に初期化済みの話者の再初期化をスキップするかどうか
func (r ApiInitializeSpeakerInitializeSpeakerPostRequest) SkipReinit(skipReinit bool) ApiInitializeSpeakerInitializeSpeakerPostRequest {
	r.skipReinit = &skipReinit
	return r
}

func (r ApiInitializeSpeakerInitializeSpeakerPostRequest) CoreVersion(coreVersion string) ApiInitializeSpeakerInitializeSpeakerPostRequest {
	r.coreVersion = &coreVersion
	return r
}

func (r ApiInitializeSpeakerInitializeSpeakerPostRequest) Execute() (*http.Response, error) {
	return r.ApiService.InitializeSpeakerInitializeSpeakerPostExecute(r)
}

/*
InitializeSpeakerInitializeSpeakerPost Initialize Speaker

指定されたspeaker_idの話者を初期化します。
実行しなくても他のAPIは使用できますが、初回実行時に時間がかかることがあります。

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiInitializeSpeakerInitializeSpeakerPostRequest
*/
func (a *DefaultApiService) InitializeSpeakerInitializeSpeakerPost(ctx context.Context) ApiInitializeSpeakerInitializeSpeakerPostRequest {
	return ApiInitializeSpeakerInitializeSpeakerPostRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
func (a *DefaultApiService) InitializeSpeakerInitializeSpeakerPostExecute(r ApiInitializeSpeakerInitializeSpeakerPostRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod = http.MethodPost
		localVarPostBody   interface{}
		formFiles          []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultApiService.InitializeSpeakerInitializeSpeakerPost")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/initialize_speaker"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.speaker == nil {
		return nil, reportError("speaker is required and must be specified")
	}

	parameterAddToHeaderOrQuery(localVarQueryParams, "speaker", r.speaker, "")
	if r.skipReinit != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "skip_reinit", r.skipReinit, "")
	}
	if r.coreVersion != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "core_version", r.coreVersion, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 422 {
			var v HTTPValidationError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiInstallLibraryInstallLibraryLibraryUuidPostRequest struct {
	ctx         context.Context
	ApiService  *DefaultApiService
	libraryUuid string
}

func (r ApiInstallLibraryInstallLibraryLibraryUuidPostRequest) Execute() (*http.Response, error) {
	return r.ApiService.InstallLibraryInstallLibraryLibraryUuidPostExecute(r)
}

/*
InstallLibraryInstallLibraryLibraryUuidPost Install Library

音声ライブラリをインストールします。
音声ライブラリのZIPファイルをリクエストボディとして送信してください。

Parameters
----------
library_uuid: str

	   音声ライブラリのID

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param libraryUuid
	@return ApiInstallLibraryInstallLibraryLibraryUuidPostRequest
*/
func (a *DefaultApiService) InstallLibraryInstallLibraryLibraryUuidPost(ctx context.Context, libraryUuid string) ApiInstallLibraryInstallLibraryLibraryUuidPostRequest {
	return ApiInstallLibraryInstallLibraryLibraryUuidPostRequest{
		ApiService:  a,
		ctx:         ctx,
		libraryUuid: libraryUuid,
	}
}

// Execute executes the request
func (a *DefaultApiService) InstallLibraryInstallLibraryLibraryUuidPostExecute(r ApiInstallLibraryInstallLibraryLibraryUuidPostRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod = http.MethodPost
		localVarPostBody   interface{}
		formFiles          []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultApiService.InstallLibraryInstallLibraryLibraryUuidPost")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/install_library/{library_uuid}"
	localVarPath = strings.Replace(localVarPath, "{"+"library_uuid"+"}", url.PathEscape(parameterValueToString(r.libraryUuid, "libraryUuid")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 422 {
			var v HTTPValidationError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiInstalledLibrariesInstalledLibrariesGetRequest struct {
	ctx        context.Context
	ApiService *DefaultApiService
}

func (r ApiInstalledLibrariesInstalledLibrariesGetRequest) Execute() ([]DownloadableLibrary, *http.Response, error) {
	return r.ApiService.InstalledLibrariesInstalledLibrariesGetExecute(r)
}

/*
InstalledLibrariesInstalledLibrariesGet Installed Libraries

インストールした音声ライブラリの情報を返します。

Returns
-------
ret_data: List[DownloadableLibrary]

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiInstalledLibrariesInstalledLibrariesGetRequest
*/
func (a *DefaultApiService) InstalledLibrariesInstalledLibrariesGet(ctx context.Context) ApiInstalledLibrariesInstalledLibrariesGetRequest {
	return ApiInstalledLibrariesInstalledLibrariesGetRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//
//	@return []DownloadableLibrary
func (a *DefaultApiService) InstalledLibrariesInstalledLibrariesGetExecute(r ApiInstalledLibrariesInstalledLibrariesGetRequest) ([]DownloadableLibrary, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue []DownloadableLibrary
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultApiService.InstalledLibrariesInstalledLibrariesGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/installed_libraries"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiIsInitializedSpeakerIsInitializedSpeakerGetRequest struct {
	ctx         context.Context
	ApiService  *DefaultApiService
	speaker     *int32
	coreVersion *string
}

func (r ApiIsInitializedSpeakerIsInitializedSpeakerGetRequest) Speaker(speaker int32) ApiIsInitializedSpeakerIsInitializedSpeakerGetRequest {
	r.speaker = &speaker
	return r
}

func (r ApiIsInitializedSpeakerIsInitializedSpeakerGetRequest) CoreVersion(coreVersion string) ApiIsInitializedSpeakerIsInitializedSpeakerGetRequest {
	r.coreVersion = &coreVersion
	return r
}

func (r ApiIsInitializedSpeakerIsInitializedSpeakerGetRequest) Execute() (bool, *http.Response, error) {
	return r.ApiService.IsInitializedSpeakerIsInitializedSpeakerGetExecute(r)
}

/*
IsInitializedSpeakerIsInitializedSpeakerGet Is Initialized Speaker

指定されたspeaker_idの話者が初期化されているかどうかを返します。

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiIsInitializedSpeakerIsInitializedSpeakerGetRequest
*/
func (a *DefaultApiService) IsInitializedSpeakerIsInitializedSpeakerGet(ctx context.Context) ApiIsInitializedSpeakerIsInitializedSpeakerGetRequest {
	return ApiIsInitializedSpeakerIsInitializedSpeakerGetRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//
//	@return bool
func (a *DefaultApiService) IsInitializedSpeakerIsInitializedSpeakerGetExecute(r ApiIsInitializedSpeakerIsInitializedSpeakerGetRequest) (bool, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue bool
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultApiService.IsInitializedSpeakerIsInitializedSpeakerGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/is_initialized_speaker"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.speaker == nil {
		return localVarReturnValue, nil, reportError("speaker is required and must be specified")
	}

	parameterAddToHeaderOrQuery(localVarQueryParams, "speaker", r.speaker, "")
	if r.coreVersion != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "core_version", r.coreVersion, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 422 {
			var v HTTPValidationError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiMoraDataMoraDataPostRequest struct {
	ctx          context.Context
	ApiService   *DefaultApiService
	speaker      *int32
	accentPhrase *[]AccentPhrase
	coreVersion  *string
}

func (r ApiMoraDataMoraDataPostRequest) Speaker(speaker int32) ApiMoraDataMoraDataPostRequest {
	r.speaker = &speaker
	return r
}

func (r ApiMoraDataMoraDataPostRequest) AccentPhrase(accentPhrase []AccentPhrase) ApiMoraDataMoraDataPostRequest {
	r.accentPhrase = &accentPhrase
	return r
}

func (r ApiMoraDataMoraDataPostRequest) CoreVersion(coreVersion string) ApiMoraDataMoraDataPostRequest {
	r.coreVersion = &coreVersion
	return r
}

func (r ApiMoraDataMoraDataPostRequest) Execute() ([]AccentPhrase, *http.Response, error) {
	return r.ApiService.MoraDataMoraDataPostExecute(r)
}

/*
MoraDataMoraDataPost アクセント句から音高・音素長を得る

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiMoraDataMoraDataPostRequest
*/
func (a *DefaultApiService) MoraDataMoraDataPost(ctx context.Context) ApiMoraDataMoraDataPostRequest {
	return ApiMoraDataMoraDataPostRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//
//	@return []AccentPhrase
func (a *DefaultApiService) MoraDataMoraDataPostExecute(r ApiMoraDataMoraDataPostRequest) ([]AccentPhrase, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPost
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue []AccentPhrase
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultApiService.MoraDataMoraDataPost")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/mora_data"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.speaker == nil {
		return localVarReturnValue, nil, reportError("speaker is required and must be specified")
	}
	if r.accentPhrase == nil {
		return localVarReturnValue, nil, reportError("accentPhrase is required and must be specified")
	}

	parameterAddToHeaderOrQuery(localVarQueryParams, "speaker", r.speaker, "")
	if r.coreVersion != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "core_version", r.coreVersion, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.accentPhrase
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 422 {
			var v HTTPValidationError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiMoraLengthMoraLengthPostRequest struct {
	ctx          context.Context
	ApiService   *DefaultApiService
	speaker      *int32
	accentPhrase *[]AccentPhrase
	coreVersion  *string
}

func (r ApiMoraLengthMoraLengthPostRequest) Speaker(speaker int32) ApiMoraLengthMoraLengthPostRequest {
	r.speaker = &speaker
	return r
}

func (r ApiMoraLengthMoraLengthPostRequest) AccentPhrase(accentPhrase []AccentPhrase) ApiMoraLengthMoraLengthPostRequest {
	r.accentPhrase = &accentPhrase
	return r
}

func (r ApiMoraLengthMoraLengthPostRequest) CoreVersion(coreVersion string) ApiMoraLengthMoraLengthPostRequest {
	r.coreVersion = &coreVersion
	return r
}

func (r ApiMoraLengthMoraLengthPostRequest) Execute() ([]AccentPhrase, *http.Response, error) {
	return r.ApiService.MoraLengthMoraLengthPostExecute(r)
}

/*
MoraLengthMoraLengthPost アクセント句から音素長を得る

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiMoraLengthMoraLengthPostRequest
*/
func (a *DefaultApiService) MoraLengthMoraLengthPost(ctx context.Context) ApiMoraLengthMoraLengthPostRequest {
	return ApiMoraLengthMoraLengthPostRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//
//	@return []AccentPhrase
func (a *DefaultApiService) MoraLengthMoraLengthPostExecute(r ApiMoraLengthMoraLengthPostRequest) ([]AccentPhrase, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPost
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue []AccentPhrase
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultApiService.MoraLengthMoraLengthPost")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/mora_length"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.speaker == nil {
		return localVarReturnValue, nil, reportError("speaker is required and must be specified")
	}
	if r.accentPhrase == nil {
		return localVarReturnValue, nil, reportError("accentPhrase is required and must be specified")
	}

	parameterAddToHeaderOrQuery(localVarQueryParams, "speaker", r.speaker, "")
	if r.coreVersion != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "core_version", r.coreVersion, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.accentPhrase
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 422 {
			var v HTTPValidationError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiMoraPitchMoraPitchPostRequest struct {
	ctx          context.Context
	ApiService   *DefaultApiService
	speaker      *int32
	accentPhrase *[]AccentPhrase
	coreVersion  *string
}

func (r ApiMoraPitchMoraPitchPostRequest) Speaker(speaker int32) ApiMoraPitchMoraPitchPostRequest {
	r.speaker = &speaker
	return r
}

func (r ApiMoraPitchMoraPitchPostRequest) AccentPhrase(accentPhrase []AccentPhrase) ApiMoraPitchMoraPitchPostRequest {
	r.accentPhrase = &accentPhrase
	return r
}

func (r ApiMoraPitchMoraPitchPostRequest) CoreVersion(coreVersion string) ApiMoraPitchMoraPitchPostRequest {
	r.coreVersion = &coreVersion
	return r
}

func (r ApiMoraPitchMoraPitchPostRequest) Execute() ([]AccentPhrase, *http.Response, error) {
	return r.ApiService.MoraPitchMoraPitchPostExecute(r)
}

/*
MoraPitchMoraPitchPost アクセント句から音高を得る

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiMoraPitchMoraPitchPostRequest
*/
func (a *DefaultApiService) MoraPitchMoraPitchPost(ctx context.Context) ApiMoraPitchMoraPitchPostRequest {
	return ApiMoraPitchMoraPitchPostRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//
//	@return []AccentPhrase
func (a *DefaultApiService) MoraPitchMoraPitchPostExecute(r ApiMoraPitchMoraPitchPostRequest) ([]AccentPhrase, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPost
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue []AccentPhrase
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultApiService.MoraPitchMoraPitchPost")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/mora_pitch"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.speaker == nil {
		return localVarReturnValue, nil, reportError("speaker is required and must be specified")
	}
	if r.accentPhrase == nil {
		return localVarReturnValue, nil, reportError("accentPhrase is required and must be specified")
	}

	parameterAddToHeaderOrQuery(localVarQueryParams, "speaker", r.speaker, "")
	if r.coreVersion != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "core_version", r.coreVersion, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.accentPhrase
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 422 {
			var v HTTPValidationError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiMorphableTargetsMorphableTargetsPostRequest struct {
	ctx         context.Context
	ApiService  *DefaultApiService
	requestBody *[]int32
	coreVersion *string
}

func (r ApiMorphableTargetsMorphableTargetsPostRequest) RequestBody(requestBody []int32) ApiMorphableTargetsMorphableTargetsPostRequest {
	r.requestBody = &requestBody
	return r
}

func (r ApiMorphableTargetsMorphableTargetsPostRequest) CoreVersion(coreVersion string) ApiMorphableTargetsMorphableTargetsPostRequest {
	r.coreVersion = &coreVersion
	return r
}

func (r ApiMorphableTargetsMorphableTargetsPostRequest) Execute() ([]map[string]MorphableTargetInfo, *http.Response, error) {
	return r.ApiService.MorphableTargetsMorphableTargetsPostExecute(r)
}

/*
MorphableTargetsMorphableTargetsPost 指定した話者に対してエンジン内の話者がモーフィングが可能か判定する

指定されたベース話者に対してエンジン内の各話者がモーフィング機能を利用可能か返します。
モーフィングの許可/禁止は`/speakers`の`speaker.supported_features.synthesis_morphing`に記載されています。
プロパティが存在しない場合は、モーフィングが許可されているとみなします。
返り値の話者はstring型なので注意。

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiMorphableTargetsMorphableTargetsPostRequest
*/
func (a *DefaultApiService) MorphableTargetsMorphableTargetsPost(ctx context.Context) ApiMorphableTargetsMorphableTargetsPostRequest {
	return ApiMorphableTargetsMorphableTargetsPostRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//
//	@return []map[string]MorphableTargetInfo
func (a *DefaultApiService) MorphableTargetsMorphableTargetsPostExecute(r ApiMorphableTargetsMorphableTargetsPostRequest) ([]map[string]MorphableTargetInfo, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPost
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue []map[string]MorphableTargetInfo
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultApiService.MorphableTargetsMorphableTargetsPost")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/morphable_targets"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.requestBody == nil {
		return localVarReturnValue, nil, reportError("requestBody is required and must be specified")
	}

	if r.coreVersion != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "core_version", r.coreVersion, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.requestBody
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 422 {
			var v HTTPValidationError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiMultiSynthesisMultiSynthesisPostRequest struct {
	ctx         context.Context
	ApiService  *DefaultApiService
	speaker     *int32
	audioQuery  *[]AudioQuery
	coreVersion *string
}

func (r ApiMultiSynthesisMultiSynthesisPostRequest) Speaker(speaker int32) ApiMultiSynthesisMultiSynthesisPostRequest {
	r.speaker = &speaker
	return r
}

func (r ApiMultiSynthesisMultiSynthesisPostRequest) AudioQuery(audioQuery []AudioQuery) ApiMultiSynthesisMultiSynthesisPostRequest {
	r.audioQuery = &audioQuery
	return r
}

func (r ApiMultiSynthesisMultiSynthesisPostRequest) CoreVersion(coreVersion string) ApiMultiSynthesisMultiSynthesisPostRequest {
	r.coreVersion = &coreVersion
	return r
}

func (r ApiMultiSynthesisMultiSynthesisPostRequest) Execute() (*os.File, *http.Response, error) {
	return r.ApiService.MultiSynthesisMultiSynthesisPostExecute(r)
}

/*
MultiSynthesisMultiSynthesisPost 複数まとめて音声合成する

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiMultiSynthesisMultiSynthesisPostRequest
*/
func (a *DefaultApiService) MultiSynthesisMultiSynthesisPost(ctx context.Context) ApiMultiSynthesisMultiSynthesisPostRequest {
	return ApiMultiSynthesisMultiSynthesisPostRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//
//	@return *os.File
func (a *DefaultApiService) MultiSynthesisMultiSynthesisPostExecute(r ApiMultiSynthesisMultiSynthesisPostRequest) (*os.File, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPost
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *os.File
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultApiService.MultiSynthesisMultiSynthesisPost")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/multi_synthesis"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.speaker == nil {
		return localVarReturnValue, nil, reportError("speaker is required and must be specified")
	}
	if r.audioQuery == nil {
		return localVarReturnValue, nil, reportError("audioQuery is required and must be specified")
	}

	parameterAddToHeaderOrQuery(localVarQueryParams, "speaker", r.speaker, "")
	if r.coreVersion != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "core_version", r.coreVersion, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/zip", "application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.audioQuery
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 422 {
			var v HTTPValidationError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiRewriteUserDictWordUserDictWordWordUuidPutRequest struct {
	ctx           context.Context
	ApiService    *DefaultApiService
	wordUuid      string
	surface       *string
	pronunciation *string
	accentType    *int32
	wordType      *WordTypes
	priority      *int32
}

func (r ApiRewriteUserDictWordUserDictWordWordUuidPutRequest) Surface(surface string) ApiRewriteUserDictWordUserDictWordWordUuidPutRequest {
	r.surface = &surface
	return r
}

func (r ApiRewriteUserDictWordUserDictWordWordUuidPutRequest) Pronunciation(pronunciation string) ApiRewriteUserDictWordUserDictWordWordUuidPutRequest {
	r.pronunciation = &pronunciation
	return r
}

func (r ApiRewriteUserDictWordUserDictWordWordUuidPutRequest) AccentType(accentType int32) ApiRewriteUserDictWordUserDictWordWordUuidPutRequest {
	r.accentType = &accentType
	return r
}

func (r ApiRewriteUserDictWordUserDictWordWordUuidPutRequest) WordType(wordType WordTypes) ApiRewriteUserDictWordUserDictWordWordUuidPutRequest {
	r.wordType = &wordType
	return r
}

func (r ApiRewriteUserDictWordUserDictWordWordUuidPutRequest) Priority(priority int32) ApiRewriteUserDictWordUserDictWordWordUuidPutRequest {
	r.priority = &priority
	return r
}

func (r ApiRewriteUserDictWordUserDictWordWordUuidPutRequest) Execute() (*http.Response, error) {
	return r.ApiService.RewriteUserDictWordUserDictWordWordUuidPutExecute(r)
}

/*
RewriteUserDictWordUserDictWordWordUuidPut Rewrite User Dict Word

ユーザー辞書に登録されている言葉を更新します。

Parameters
----------
surface : str

	言葉の表層形

pronunciation: str

	言葉の発音（カタカナ）

accent_type: int

	アクセント型（音が下がる場所を指す）

word_uuid: str

	更新する言葉のUUID

word_type: WordTypes, optional

	PROPER_NOUN（固有名詞）、COMMON_NOUN（普通名詞）、VERB（動詞）、ADJECTIVE（形容詞）、SUFFIX（語尾）のいずれか

priority: int, optional

	   単語の優先度（0から10までの整数）
	   数字が大きいほど優先度が高くなる
	   1から9までの値を指定することを推奨

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param wordUuid
	@return ApiRewriteUserDictWordUserDictWordWordUuidPutRequest
*/
func (a *DefaultApiService) RewriteUserDictWordUserDictWordWordUuidPut(ctx context.Context, wordUuid string) ApiRewriteUserDictWordUserDictWordWordUuidPutRequest {
	return ApiRewriteUserDictWordUserDictWordWordUuidPutRequest{
		ApiService: a,
		ctx:        ctx,
		wordUuid:   wordUuid,
	}
}

// Execute executes the request
func (a *DefaultApiService) RewriteUserDictWordUserDictWordWordUuidPutExecute(r ApiRewriteUserDictWordUserDictWordWordUuidPutRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod = http.MethodPut
		localVarPostBody   interface{}
		formFiles          []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultApiService.RewriteUserDictWordUserDictWordWordUuidPut")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/user_dict_word/{word_uuid}"
	localVarPath = strings.Replace(localVarPath, "{"+"word_uuid"+"}", url.PathEscape(parameterValueToString(r.wordUuid, "wordUuid")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.surface == nil {
		return nil, reportError("surface is required and must be specified")
	}
	if r.pronunciation == nil {
		return nil, reportError("pronunciation is required and must be specified")
	}
	if r.accentType == nil {
		return nil, reportError("accentType is required and must be specified")
	}

	parameterAddToHeaderOrQuery(localVarQueryParams, "surface", r.surface, "")
	parameterAddToHeaderOrQuery(localVarQueryParams, "pronunciation", r.pronunciation, "")
	parameterAddToHeaderOrQuery(localVarQueryParams, "accent_type", r.accentType, "")
	if r.wordType != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "word_type", r.wordType, "")
	}
	if r.priority != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "priority", r.priority, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 422 {
			var v HTTPValidationError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiSettingGetSettingGetRequest struct {
	ctx        context.Context
	ApiService *DefaultApiService
}

func (r ApiSettingGetSettingGetRequest) Execute() (string, *http.Response, error) {
	return r.ApiService.SettingGetSettingGetExecute(r)
}

/*
SettingGetSettingGet Setting Get

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiSettingGetSettingGetRequest
*/
func (a *DefaultApiService) SettingGetSettingGet(ctx context.Context) ApiSettingGetSettingGetRequest {
	return ApiSettingGetSettingGetRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//
//	@return string
func (a *DefaultApiService) SettingGetSettingGetExecute(r ApiSettingGetSettingGetRequest) (string, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue string
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultApiService.SettingGetSettingGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/setting"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"text/html"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiSettingPostSettingPostRequest struct {
	ctx            context.Context
	ApiService     *DefaultApiService
	corsPolicyMode *string
	allowOrigin    *string
}

func (r ApiSettingPostSettingPostRequest) CorsPolicyMode(corsPolicyMode string) ApiSettingPostSettingPostRequest {
	r.corsPolicyMode = &corsPolicyMode
	return r
}

func (r ApiSettingPostSettingPostRequest) AllowOrigin(allowOrigin string) ApiSettingPostSettingPostRequest {
	r.allowOrigin = &allowOrigin
	return r
}

func (r ApiSettingPostSettingPostRequest) Execute() (string, *http.Response, error) {
	return r.ApiService.SettingPostSettingPostExecute(r)
}

/*
SettingPostSettingPost Setting Post

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiSettingPostSettingPostRequest
*/
func (a *DefaultApiService) SettingPostSettingPost(ctx context.Context) ApiSettingPostSettingPostRequest {
	return ApiSettingPostSettingPostRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//
//	@return string
func (a *DefaultApiService) SettingPostSettingPostExecute(r ApiSettingPostSettingPostRequest) (string, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPost
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue string
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultApiService.SettingPostSettingPost")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/setting"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/x-www-form-urlencoded"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"text/html", "application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.corsPolicyMode != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "cors_policy_mode", r.corsPolicyMode, "")
	}
	if r.allowOrigin != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "allow_origin", r.allowOrigin, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 422 {
			var v HTTPValidationError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiSpeakerInfoSpeakerInfoGetRequest struct {
	ctx         context.Context
	ApiService  *DefaultApiService
	speakerUuid *string
	coreVersion *string
}

func (r ApiSpeakerInfoSpeakerInfoGetRequest) SpeakerUuid(speakerUuid string) ApiSpeakerInfoSpeakerInfoGetRequest {
	r.speakerUuid = &speakerUuid
	return r
}

func (r ApiSpeakerInfoSpeakerInfoGetRequest) CoreVersion(coreVersion string) ApiSpeakerInfoSpeakerInfoGetRequest {
	r.coreVersion = &coreVersion
	return r
}

func (r ApiSpeakerInfoSpeakerInfoGetRequest) Execute() (*SpeakerInfo, *http.Response, error) {
	return r.ApiService.SpeakerInfoSpeakerInfoGetExecute(r)
}

/*
SpeakerInfoSpeakerInfoGet Speaker Info

指定されたspeaker_uuidに関する情報をjson形式で返します。
画像や音声はbase64エンコードされたものが返されます。

Returns
-------
ret_data: SpeakerInfo

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiSpeakerInfoSpeakerInfoGetRequest
*/
func (a *DefaultApiService) SpeakerInfoSpeakerInfoGet(ctx context.Context) ApiSpeakerInfoSpeakerInfoGetRequest {
	return ApiSpeakerInfoSpeakerInfoGetRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//
//	@return SpeakerInfo
func (a *DefaultApiService) SpeakerInfoSpeakerInfoGetExecute(r ApiSpeakerInfoSpeakerInfoGetRequest) (*SpeakerInfo, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *SpeakerInfo
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultApiService.SpeakerInfoSpeakerInfoGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/speaker_info"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.speakerUuid == nil {
		return localVarReturnValue, nil, reportError("speakerUuid is required and must be specified")
	}

	parameterAddToHeaderOrQuery(localVarQueryParams, "speaker_uuid", r.speakerUuid, "")
	if r.coreVersion != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "core_version", r.coreVersion, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 422 {
			var v HTTPValidationError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiSpeakersSpeakersGetRequest struct {
	ctx         context.Context
	ApiService  *DefaultApiService
	coreVersion *string
}

func (r ApiSpeakersSpeakersGetRequest) CoreVersion(coreVersion string) ApiSpeakersSpeakersGetRequest {
	r.coreVersion = &coreVersion
	return r
}

func (r ApiSpeakersSpeakersGetRequest) Execute() ([]Speaker, *http.Response, error) {
	return r.ApiService.SpeakersSpeakersGetExecute(r)
}

/*
SpeakersSpeakersGet Speakers

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiSpeakersSpeakersGetRequest
*/
func (a *DefaultApiService) SpeakersSpeakersGet(ctx context.Context) ApiSpeakersSpeakersGetRequest {
	return ApiSpeakersSpeakersGetRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//
//	@return []Speaker
func (a *DefaultApiService) SpeakersSpeakersGetExecute(r ApiSpeakersSpeakersGetRequest) ([]Speaker, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue []Speaker
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultApiService.SpeakersSpeakersGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/speakers"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.coreVersion != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "core_version", r.coreVersion, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 422 {
			var v HTTPValidationError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiSupportedDevicesSupportedDevicesGetRequest struct {
	ctx         context.Context
	ApiService  *DefaultApiService
	coreVersion *string
}

func (r ApiSupportedDevicesSupportedDevicesGetRequest) CoreVersion(coreVersion string) ApiSupportedDevicesSupportedDevicesGetRequest {
	r.coreVersion = &coreVersion
	return r
}

func (r ApiSupportedDevicesSupportedDevicesGetRequest) Execute() (*SupportedDevicesInfo, *http.Response, error) {
	return r.ApiService.SupportedDevicesSupportedDevicesGetExecute(r)
}

/*
SupportedDevicesSupportedDevicesGet Supported Devices

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiSupportedDevicesSupportedDevicesGetRequest
*/
func (a *DefaultApiService) SupportedDevicesSupportedDevicesGet(ctx context.Context) ApiSupportedDevicesSupportedDevicesGetRequest {
	return ApiSupportedDevicesSupportedDevicesGetRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//
//	@return SupportedDevicesInfo
func (a *DefaultApiService) SupportedDevicesSupportedDevicesGetExecute(r ApiSupportedDevicesSupportedDevicesGetRequest) (*SupportedDevicesInfo, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *SupportedDevicesInfo
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultApiService.SupportedDevicesSupportedDevicesGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/supported_devices"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.coreVersion != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "core_version", r.coreVersion, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 422 {
			var v HTTPValidationError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiSynthesisMorphingSynthesisMorphingPostRequest struct {
	ctx           context.Context
	ApiService    *DefaultApiService
	baseSpeaker   *int32
	targetSpeaker *int32
	morphRate     *float32
	audioQuery    *AudioQuery
	coreVersion   *string
}

func (r ApiSynthesisMorphingSynthesisMorphingPostRequest) BaseSpeaker(baseSpeaker int32) ApiSynthesisMorphingSynthesisMorphingPostRequest {
	r.baseSpeaker = &baseSpeaker
	return r
}

func (r ApiSynthesisMorphingSynthesisMorphingPostRequest) TargetSpeaker(targetSpeaker int32) ApiSynthesisMorphingSynthesisMorphingPostRequest {
	r.targetSpeaker = &targetSpeaker
	return r
}

func (r ApiSynthesisMorphingSynthesisMorphingPostRequest) MorphRate(morphRate float32) ApiSynthesisMorphingSynthesisMorphingPostRequest {
	r.morphRate = &morphRate
	return r
}

func (r ApiSynthesisMorphingSynthesisMorphingPostRequest) AudioQuery(audioQuery AudioQuery) ApiSynthesisMorphingSynthesisMorphingPostRequest {
	r.audioQuery = &audioQuery
	return r
}

func (r ApiSynthesisMorphingSynthesisMorphingPostRequest) CoreVersion(coreVersion string) ApiSynthesisMorphingSynthesisMorphingPostRequest {
	r.coreVersion = &coreVersion
	return r
}

func (r ApiSynthesisMorphingSynthesisMorphingPostRequest) Execute() (*os.File, *http.Response, error) {
	return r.ApiService.SynthesisMorphingSynthesisMorphingPostExecute(r)
}

/*
SynthesisMorphingSynthesisMorphingPost 2人の話者でモーフィングした音声を合成する

指定された2人の話者で音声を合成、指定した割合でモーフィングした音声を得ます。
モーフィングの割合は`morph_rate`で指定でき、0.0でベースの話者、1.0でターゲットの話者に近づきます。

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiSynthesisMorphingSynthesisMorphingPostRequest
*/
func (a *DefaultApiService) SynthesisMorphingSynthesisMorphingPost(ctx context.Context) ApiSynthesisMorphingSynthesisMorphingPostRequest {
	return ApiSynthesisMorphingSynthesisMorphingPostRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//
//	@return *os.File
func (a *DefaultApiService) SynthesisMorphingSynthesisMorphingPostExecute(r ApiSynthesisMorphingSynthesisMorphingPostRequest) (*os.File, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPost
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *os.File
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultApiService.SynthesisMorphingSynthesisMorphingPost")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/synthesis_morphing"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.baseSpeaker == nil {
		return localVarReturnValue, nil, reportError("baseSpeaker is required and must be specified")
	}
	if r.targetSpeaker == nil {
		return localVarReturnValue, nil, reportError("targetSpeaker is required and must be specified")
	}
	if r.morphRate == nil {
		return localVarReturnValue, nil, reportError("morphRate is required and must be specified")
	}
	if *r.morphRate < 0 {
		return localVarReturnValue, nil, reportError("morphRate must be greater than 0")
	}
	if *r.morphRate > 1 {
		return localVarReturnValue, nil, reportError("morphRate must be less than 1")
	}
	if r.audioQuery == nil {
		return localVarReturnValue, nil, reportError("audioQuery is required and must be specified")
	}

	parameterAddToHeaderOrQuery(localVarQueryParams, "base_speaker", r.baseSpeaker, "")
	parameterAddToHeaderOrQuery(localVarQueryParams, "target_speaker", r.targetSpeaker, "")
	parameterAddToHeaderOrQuery(localVarQueryParams, "morph_rate", r.morphRate, "")
	if r.coreVersion != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "core_version", r.coreVersion, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"audio/wav", "application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.audioQuery
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 422 {
			var v HTTPValidationError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiSynthesisSynthesisPostRequest struct {
	ctx                        context.Context
	ApiService                 *DefaultApiService
	speaker                    *int32
	audioQuery                 *AudioQuery
	enableInterrogativeUpspeak *bool
	coreVersion                *string
}

func (r ApiSynthesisSynthesisPostRequest) Speaker(speaker int32) ApiSynthesisSynthesisPostRequest {
	r.speaker = &speaker
	return r
}

func (r ApiSynthesisSynthesisPostRequest) AudioQuery(audioQuery AudioQuery) ApiSynthesisSynthesisPostRequest {
	r.audioQuery = &audioQuery
	return r
}

// 疑問系のテキストが与えられたら語尾を自動調整する
func (r ApiSynthesisSynthesisPostRequest) EnableInterrogativeUpspeak(enableInterrogativeUpspeak bool) ApiSynthesisSynthesisPostRequest {
	r.enableInterrogativeUpspeak = &enableInterrogativeUpspeak
	return r
}

func (r ApiSynthesisSynthesisPostRequest) CoreVersion(coreVersion string) ApiSynthesisSynthesisPostRequest {
	r.coreVersion = &coreVersion
	return r
}

func (r ApiSynthesisSynthesisPostRequest) Execute() (*os.File, *http.Response, error) {
	return r.ApiService.SynthesisSynthesisPostExecute(r)
}

/*
SynthesisSynthesisPost 音声合成する

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiSynthesisSynthesisPostRequest
*/
func (a *DefaultApiService) SynthesisSynthesisPost(ctx context.Context) ApiSynthesisSynthesisPostRequest {
	return ApiSynthesisSynthesisPostRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//
//	@return *os.File
func (a *DefaultApiService) SynthesisSynthesisPostExecute(r ApiSynthesisSynthesisPostRequest) (*os.File, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPost
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *os.File
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultApiService.SynthesisSynthesisPost")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/synthesis"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.speaker == nil {
		return localVarReturnValue, nil, reportError("speaker is required and must be specified")
	}
	if r.audioQuery == nil {
		return localVarReturnValue, nil, reportError("audioQuery is required and must be specified")
	}

	parameterAddToHeaderOrQuery(localVarQueryParams, "speaker", r.speaker, "")
	if r.enableInterrogativeUpspeak != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "enable_interrogative_upspeak", r.enableInterrogativeUpspeak, "")
	}
	if r.coreVersion != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "core_version", r.coreVersion, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"audio/wav", "application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.audioQuery
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 422 {
			var v HTTPValidationError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiUpdatePresetUpdatePresetPostRequest struct {
	ctx        context.Context
	ApiService *DefaultApiService
	preset     *Preset
}

func (r ApiUpdatePresetUpdatePresetPostRequest) Preset(preset Preset) ApiUpdatePresetUpdatePresetPostRequest {
	r.preset = &preset
	return r
}

func (r ApiUpdatePresetUpdatePresetPostRequest) Execute() (int32, *http.Response, error) {
	return r.ApiService.UpdatePresetUpdatePresetPostExecute(r)
}

/*
UpdatePresetUpdatePresetPost Update Preset

既存のプリセットを更新します

Parameters
-------
preset: Preset

	更新するプリセット。
	プリセットIDが更新対象と一致している必要があります。

Returns
-------
id: int

	   更新したプリセットのプリセットID

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiUpdatePresetUpdatePresetPostRequest
*/
func (a *DefaultApiService) UpdatePresetUpdatePresetPost(ctx context.Context) ApiUpdatePresetUpdatePresetPostRequest {
	return ApiUpdatePresetUpdatePresetPostRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//
//	@return int32
func (a *DefaultApiService) UpdatePresetUpdatePresetPostExecute(r ApiUpdatePresetUpdatePresetPostRequest) (int32, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPost
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue int32
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultApiService.UpdatePresetUpdatePresetPost")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/update_preset"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.preset == nil {
		return localVarReturnValue, nil, reportError("preset is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.preset
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 422 {
			var v HTTPValidationError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiVersionVersionGetRequest struct {
	ctx        context.Context
	ApiService *DefaultApiService
}

func (r ApiVersionVersionGetRequest) Execute() (interface{}, *http.Response, error) {
	return r.ApiService.VersionVersionGetExecute(r)
}

/*
VersionVersionGet Version

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiVersionVersionGetRequest
*/
func (a *DefaultApiService) VersionVersionGet(ctx context.Context) ApiVersionVersionGetRequest {
	return ApiVersionVersionGetRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//
//	@return interface{}
func (a *DefaultApiService) VersionVersionGetExecute(r ApiVersionVersionGetRequest) (interface{}, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue interface{}
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultApiService.VersionVersionGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/version"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}
